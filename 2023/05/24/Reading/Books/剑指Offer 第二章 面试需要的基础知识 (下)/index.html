<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-yuki.PNG">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-yuki.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-yuki.png">
  <link rel="mask-icon" href="/images/logo-yuki.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"yukief4fdh.github.io","root":"/","images":"/images","scheme":"Gemini","version":"8.7.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>
<meta name="description" content="第二章 面试需要的基础知识 (下) 2.3 数据结构 技术面试的重点。几种常见的数据结构包括:  数组和字符串。用连续内存分别存储数字和字符。 链表和树。操作涉及大量的指针，留意代码的鲁棒性。 栈和队列。分别与递归和广度优先遍历算法紧密相关。">
<meta property="og:type" content="article">
<meta property="og:title" content="《剑指Offer》第二章 笔记(下)">
<meta property="og:url" content="https://yukief4fdh.github.io/2023/05/24/Reading/Books/%E5%89%91%E6%8C%87Offer%20%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E9%9D%A2%E8%AF%95%E9%9C%80%E8%A6%81%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%20(%E4%B8%8B)/index.html">
<meta property="og:site_name" content="Yuki&#39;s Blog">
<meta property="og:description" content="第二章 面试需要的基础知识 (下) 2.3 数据结构 技术面试的重点。几种常见的数据结构包括:  数组和字符串。用连续内存分别存储数字和字符。 链表和树。操作涉及大量的指针，留意代码的鲁棒性。 栈和队列。分别与递归和广度优先遍历算法紧密相关。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://gyazo.com/a4f79bf7011e8dcfe62a62e5b5bffab2.png">
<meta property="og:image" content="https://gyazo.com/6e8d51b69038b0ff27b4b1a3cff63749.png">
<meta property="og:image" content="https://gyazo.com/0e2acb34ef5f0ee675b94dda1a3f8c96.png">
<meta property="og:image" content="https://gyazo.com/3118a8bbf855ae2309d9338d75c6db88.png">
<meta property="og:image" content="https://gyazo.com/2df8d4e32ef7adc59b4e076cd3dcc1c6.png">
<meta property="og:image" content="https://gyazo.com/29ea363369a9986089259863834dbd3c.png">
<meta property="og:image" content="https://gyazo.com/b43ef2c8038330de5ab987939afb5570.png">
<meta property="og:image" content="https://gyazo.com/c7f8066bc686a31c224106376b3c27dd.png">
<meta property="og:image" content="https://gyazo.com/c7f8066bc686a31c224106376b3c27dd.png">
<meta property="og:image" content="https://gyazo.com/817afe3c78f09df19906ccca04399231.png">
<meta property="og:image" content="https://gyazo.com/131413d2cd8d18c3e9ea54194da4766c.png">
<meta property="article:published_time" content="2023-05-24T10:22:36.097Z">
<meta property="article:modified_time" content="2022-02-18T09:45:16.272Z">
<meta property="article:author" content="CHEN XUEYI">
<meta property="article:tag" content="剑指Offer">
<meta property="article:tag" content="读书笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gyazo.com/a4f79bf7011e8dcfe62a62e5b5bffab2.png">


<link rel="canonical" href="https://yukief4fdh.github.io/2023/05/24/Reading/Books/%E5%89%91%E6%8C%87Offer%20%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E9%9D%A2%E8%AF%95%E9%9C%80%E8%A6%81%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%20(%E4%B8%8B)/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://yukief4fdh.github.io/2023/05/24/Reading/Books/%E5%89%91%E6%8C%87Offer%20%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E9%9D%A2%E8%AF%95%E9%9C%80%E8%A6%81%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%20(%E4%B8%8B)/","path":"2023/05/24/Reading/Books/剑指Offer 第二章 面试需要的基础知识 (下)/","title":"《剑指Offer》第二章 笔记(下)"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>《剑指Offer》第二章 笔记(下) | Yuki's Blog</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Yuki's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <img class="custom-logo-image" src="/uploads/test.png" alt="Yuki's Blog">
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">28</span></a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories<span class="badge">15</span></a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">86</span></a></li>
        
            
  <li class="menu-item menu-item-docs"><a href="/docs/" rel="section"><i class="fa fa-book fa-fw"></i>Docs</a></li>


      
        <li class="menu-item menu-item-schedule"><a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a></li>
        <li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li>
        <li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E9%9D%A2%E8%AF%95%E9%9C%80%E8%A6%81%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E4%B8%8B"><span class="nav-number">1.</span> <span class="nav-text">第二章 面试需要的基础知识
(下)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.</span> <span class="nav-text">2.3 数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">1.1.1.</span> <span class="nav-text">2.3.1 数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%983%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">面试题3：二维数组中的查找</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.1.2.</span> <span class="nav-text">2.3.2　字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%984%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">面试题4：替换空格</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8"><span class="nav-number">1.1.3.</span> <span class="nav-text">2.3.3　链表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%985%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">面试题5：从尾到头打印链表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91"><span class="nav-number">1.1.4.</span> <span class="nav-text">2.3.4　树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%986%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">面试题6：重建二叉树</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="nav-number">1.1.5.</span> <span class="nav-text">2.3.5 栈和队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%987%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="nav-number">1.1.5.1.</span> <span class="nav-text">面试题7：用两个栈实现队列</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C"><span class="nav-number">1.2.</span> <span class="nav-text">2.4 算法和数据操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E5%92%8C%E6%8E%92%E5%BA%8F"><span class="nav-number">1.2.1.</span> <span class="nav-text">2.4.1 查找和排序</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="CHEN XUEYI"
      src="/images/yuki.gif">
  <p class="site-author-name" itemprop="name">CHEN XUEYI</p>
  <div class="site-description" itemprop="description">Call me Yuki (JPN) or Chloe (ENG).<br> Nice to meet you :)<br><hr style="margin:3px;"> Tokyo Institute of Technology (M1)<br> Rearch Interest: Visualization</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">86</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/YukiEF4FDH" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;YukiEF4FDH" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/xueyichen_980221@outlook.com" title="E-Mail → xueyichen_980221@outlook.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/YukiEF4FDH" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;YukiEF4FDH" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



          </div>
        </div>
      </div>

      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=591027&auto=1&height=66"></iframe>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://yukief4fdh.github.io/2023/05/24/Reading/Books/%E5%89%91%E6%8C%87Offer%20%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E9%9D%A2%E8%AF%95%E9%9C%80%E8%A6%81%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%20(%E4%B8%8B)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yuki.gif">
      <meta itemprop="name" content="CHEN XUEYI">
      <meta itemprop="description" content="Call me Yuki (JPN) or Chloe (ENG).<br> Nice to meet you :)<br><hr style="margin:3px;"> Tokyo Institute of Technology (M1)<br> Rearch Interest: Visualization">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuki's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          《剑指Offer》第二章 笔记(下)
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-05-24 19:22:36" itemprop="dateCreated datePublished" datetime="2023-05-24T19:22:36+09:00">2023-05-24</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2022-02-18 18:45:16" itemprop="dateModified" datetime="2022-02-18T18:45:16+09:00">2022-02-18</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Reading/" itemprop="url" rel="index"><span itemprop="name">Reading</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Reading/Books/" itemprop="url" rel="index"><span itemprop="name">Books</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Reading/Books/Computer-Science/" itemprop="url" rel="index"><span itemprop="name">Computer Science</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="第二章-面试需要的基础知识-下">第二章 面试需要的基础知识
(下)</h1>
<h2 id="数据结构">2.3 数据结构</h2>
<p>技术面试的重点。几种常见的数据结构包括:</p>
<ul>
<li><strong>数组和字符串</strong>。用连续内存分别存储数字和字符。</li>
<li><strong>链表和树</strong>。操作涉及大量的指针，留意代码的鲁棒性。</li>
<li><strong>栈和队列</strong>。分别与递归和广度优先遍历算法紧密相关。</li>
</ul>
<span id="more"></span>
<h3 id="数组">2.3.1 数组</h3>
<p>占据一块==连续的内存==并按照==顺序存储==数据。
创建数组时，需要==首先指定数组的容量大小==，然后根据大小==预先分配内存==。</p>
<p>数组的==空间效率不是很好==，常有空闲的区域没有得到充分利用。
数组的==时间效率很好==，由于数组中的内存是连续的，可以根据下标在<span
class="math inline">\(O(1)\)</span> 时间读/写元素。</p>
<p>可以根据数组时间效率高的优点来==实现简单的哈希表==：
下标设为哈希表的键值 (Key) ，值设为哈希表的值 (Value)
，组成键值－值的配对。 有了这样的哈希表，可以在<span
class="math inline">\(O(1)\)</span>
实现查找，从而可以快速高效地解决很多问题。</p>
<p>为了解决数组空间效率不高的问题，设计实现了多种==动态数组==，比如C++的STL中的<code>vector</code>。
为数组开辟较小的空间，当目前容量不够用时再重新分配一块更大的空间
(<code>vector</code>: 每次扩充容量时，新的容量都是前一次的两倍)，
把之前的数据复制到新的数组中，再把之前的内存释放，减少内存的浪费。
但==扩充数组是消耗很大的操作==，对时间性能有负面影响，
因此使用动态数组时要尽量减少改变数组容量大小的次数。</p>
<p>在C/C++中，当声明一个数组时，数组的名字也是一个指针，指向数组的第一个元素。
可以用一个指针来访问数组。</p>
<p>但C/C++没有记录数组的大小，因此用指针访问数组中的元素时要确保不会越界。</p>
<p><strong>例子: 运行下面的代码，请问输出是什么？</strong></p>
<center>
<img src="https://gyazo.com/a4f79bf7011e8dcfe62a62e5b5bffab2.png" style="zoom:50%;" />
</center>
<blockquote>
<p><code>data1</code>是一个数组，<code>sizeof(data1)</code>是求数组大小，因此是<code>20</code>字节。
<code>data2</code>声明为指针，<code>sizeof(data2)</code>在32位系统上是<code>4</code>字节。
C/C++中，当数组作为函数的参数进行传递时会自动退化为同类型的指针。
因此尽管函数<code>GetSize</code>的参数<code>data</code>被声明为数组，但它会退化为指针，<code>size3</code>的结果仍然是<code>4</code>。</p>
</blockquote>
<h4 id="面试题3二维数组中的查找">面试题3：二维数组中的查找</h4>
<p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。
请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
例如下面的二维数组就是每行、每列都递增排序。</p>
<p><img src="https://gyazo.com/6e8d51b69038b0ff27b4b1a3cff63749.png" style="zoom:67%;" /></p>
<p>如果在这个数组中查找数字<code>7</code>，则返回<code>true</code>；如果查找数字<code>5</code>，由于数组不含有该数字，则返回<code>false</code>。</p>
<blockquote>
<p>在分析这个问题的时，很多人都会从数组中选取一个数字
(深色)，分3种情况来分析查找的过程。</p>
<center>
<img src="https://gyazo.com/0e2acb34ef5f0ee675b94dda1a3f8c96.png" style="zoom: 50%;" >
</center>
<p>当数组中选取的数字刚好和要查找的数字相等时，就结束查找过程。
如果选取的数字小于要查找的数字，则目标应该在当前选取的位置的右边或者下边
(图2.1 (a)) 。
如果选取的数字大于要查找的数字，则目标应该在当前选取的位置的上边或者左边
(图2.1 (b))
。在上面的分析中，由于目标可能在两个区域中出现，而且这两个区域还有重叠，会比较复杂。
分析复杂问题时，一个很有效的办法是从一个简单具体的例子来寻找普遍的规律。</p>
</blockquote>
<blockquote>
<p>以查找数字<code>7</code>为例来一步步分析查找的过程。
之前我们在二维数组的<em>中间</em>选取目标，于是下一次要查找的是两个相互重叠的区域。
如果我们从数组的一个<em>角</em>上选取目标，情况会不会变简单呢？
过程如下图。</p>
<center>
<img src="https://gyazo.com/3118a8bbf855ae2309d9338d75c6db88.png" style="zoom:50%;" />
</center>
<p>总结上述查找的过程，我们发现如下规律： 首先选取数组中右上角的数字。
如果该数字等于要查找的数字，查找过程结束；
如果该数字大于要查找的数字，剔除这个数字所在的列；
如果该数字小于要查找的数字，剔除这个数字所在的行。
这样每一步都可以缩小查找的范围，直到找到要查找的数字，或者查找范围为空。</p>
<p>下面是上述思路对应的参考代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> *matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> columns, <span class="keyword">int</span> number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (matrix != <span class="literal">NULL</span> &amp;&amp; rows&gt;<span class="number">0</span> &amp;&amp; columns&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> column = columns - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(row&lt;rows &amp;&amp; column &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[row * columns + column] )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>同理，我们也可以选取左下角的数字。
但我们不能选择左上角或者右下角的数字。
以左上角为例，如果当前的数字小于目标，则目标应该位于当前数字的右边或者下边，此时无法缩小查找范围。</p>
</blockquote>
<blockquote>
<p><strong>测试用例</strong>：</p>
<ul>
<li>包含查找的数字（是数组中的最大值和最小值;
介于数组中的最大值和最小值之间）。</li>
<li>没有查找的数字（大于数组中的最大值，小于数组中的最小值，在数组的最大值和最小值之间但数组中没有这个数字）。</li>
<li>特殊输入测试（输入空指针）。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>本题考点</strong>：</p>
<ul>
<li>考查应聘者对二维数组的理解及编程能力。
可以根据行号和列号计算出相对于数组首地址的偏移量，从而找到对应的元素。</li>
<li>考查应聘者分析问题的能力。
发现问题比较复杂时，能不能通过具体的例子找出其中的规律。</li>
</ul>
</blockquote>
<h3 id="字符串">2.3.2　字符串</h3>
<p>字符串是由若干字符组成的序列。
字符串的==使用频率非常高==。为了优化，很多语言都对字符串做了==特殊的规定==。</p>
<p>C/C++中每个字符串都以字符<code>'\0'</code>作为结尾，这样就能很方便地找到尾部。
但由于这个特点，每个字符串中都有一个额外字符的开销。</p>
<p>为了节省内存，C/C++把==常量字符串==放到单独的一个内存区域。
当几个指针赋值给相同的常量字符串时，它们实际上会指向相同的内存地址。
但用==常量内存初始化数组==，情况却有所不同。</p>
<p><strong>例题: 运行下面的代码，得到的结果是什么？</strong></p>
<p><img
src="https://gyazo.com/1438ca5572b5e8e4520da8ac4700e5fa.png" /></p>
<blockquote>
<p>第一行: ”str1 and str2 are not same”。
<code>str1</code>和<code>str2</code>是两个初始地址不同的字符串数组，
会为它们分配两个长度为12个字节的空间，并把<code>"hello world"</code>的内容分别复制到数组中去。</p>
<p>第二行: "str3 and str4 are same"。
<code>str3</code>和<code>str4</code>是两个指针，因此不会被分配内存以存储字符串的内容，
而只需要把它们指向<code>"hello world”</code>在内存中的地址就可以了。
由于<code>"hello world”</code>是常量字符串，它在内存中只有一个拷贝，因此<code>str3</code>和<code>str4</code>指向的是同一个地址。</p>
</blockquote>
<p>在C#中，封装字符串的类型<code>System.String</code>中的内容是不能改变的。
一旦试图改变<code>String</code>的内容，就会产生一个新的实例。例如:</p>
<p><img src="https://gyazo.com/2df8d4e32ef7adc59b4e076cd3dcc1c6.png" style="zoom:50%;" /></p>
<p>在上述代码中，对<code>str</code>做了<code>ToUpper</code>和<code>Insert</code>两个操作，
但结果都是生成一个新的<code>String</code>实例并返回，<code>str</code>本身的内容不会发生改变。
用<code>String</code>作连续多次修改，每一次修改都会产生一个临时对象，这样开销太大会影响效率。
为此C#定义了一个新的与字符串相关的类型<code>StringBuilder</code>，它能容纳修改后的结果。</p>
<p>类似，如果我们试图把一个常量字符串赋值给一个<code>String</code>实例，
也不是把<code>String</code>的内容改成赋值的字符串，而是生成一个新的<code>String</code>实例。例如:</p>
<center>
<p><img src="https://gyazo.com/29ea363369a9986089259863834dbd3c.png" style="zoom: 67%;" /></p>
<p>在上面的代码中，先判断<code>String</code>是值类型还是引用类型。
类型<code>String</code>的定义是<code>public sealed class String &#123;...&#125;</code>。既然是<code>class</code>，那么<code>String</code>自然就是引用类型。
接下来在方法<code>ModifyString</code>里，对<code>text</code>赋值一个新的字符串。
但<code>text</code>的内容是不能被修改的。
此时会先生成一个新的内容是<code>"world"</code>的<code>String</code>实例，然后把<code>text</code>指向这个新的实例。
由于参数<code>text</code>没有加<code>ref</code>或者<code>out</code>，出了方法<code>ModifyString</code>之后，<code>text</code>还是指向原来的字符串，因此输出仍然是<code>"hello"</code>。</p>
<h4 id="面试题4替换空格">面试题4：替换空格</h4>
<p>请实现一个函数，把字符串中的每个空格替换成"%20"。
例如输入<code>“We are happy.”</code>，则输出<code>“We%20are%20happy.”</code>。</p>
<p>在网络编程中，如果URL参数中含有特殊字符，如空格、<code>'#'</code>等，可能导致服务器端无法获得正确的参数值。
需要将这些特殊符号转换成服务器可以识别的字符。
转换的规则是在<code>'%'</code>后面跟上ASCII码的两位十六进制的表示。</p>
<blockquote>
<p>如果是在原来的字符串上做替换，那么就有可能覆盖修改在该字符串后面的内存。
如果是创建新的字符串并在新的字符串上做替换，那么我们可以自己分配足够多的内存。
我们应该向面试官问清楚，让他明确告诉我们他的需求。</p>
<p>假设面试官让我们在原来的字符串上做替换，并且保证输入的字符串后面有足够多的空余内存。</p>
</blockquote>
<blockquote>
<p><strong>时间复杂度为<span class="math inline">\(O
(n^2)\)</span>的解法:</strong>
最直观的做法是从头到尾扫描字符串，每一次碰到空格字符的时候做替换。
由于是把1个字符替换成3个字符，我们必须要把空格后面所有的字符都后移两个字节，如图所示。</p>
<center>
<img src="https://gyazo.com/b43ef2c8038330de5ab987939afb5570.png" style="zoom: 80%;" />
</center>
<p>假设字符串的长度是<span class="math inline">\(n\)</span>。
对每个空格字符，需要移动后面<span
class="math inline">\(O(n)\)</span>个字符，因此对含有<span
class="math inline">\(O(n)\)</span>个空格字符的字符串而言总的时间效率是<span
class="math inline">\(O(n^2)\)</span>。</p>
<p>数组中很多字符都移动了很多次，能不能减少移动次数呢？
可以换一种思路，把从前向后替换改成从后向前替换。</p>
</blockquote>
<blockquote>
<p><strong>时间复杂度为<span
class="math inline">\(O(n)\)</span>的解法:</strong>
可以先遍历一次字符串，统计出字符串中空格的总数，并由此计算出替换之后的字符串的总长度。
每替换一个空格，长度增加2，因此替换以后字符串的长度等于原来的长度加上2乘以空格数目。</p>
<p>我们从字符串的后面开始复制和替换。
首先准备两个指针，<code>P1</code>指向原始字符串的末尾，而<code>P2</code>指向替换之后的字符串的末尾。
接下来向前移动指针P1，逐个把它指向的字符复制到P2指向的位置，直到碰到第一个空格为止。
此时把P1向前移动1格，在P2之前插入字符串"%20"并将P2向前移动3格，如此类推。</p>
<p><img
src="https://gyazo.com/67dfa70ea1c1b6392ccd2cbfe3c0db1d.png" /></p>
<p>面试时，==可以用示意图解释自己的思路==，使我们和面试官的交流变得更加高效。
在面试官肯定我们的思路之后，就可以开始写代码了:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// length为数组string的总容量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReplaceBlank</span><span class="params">(<span class="keyword">char</span> string[], <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (string == <span class="literal">NULL</span> &amp;&amp; length &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// originalLength为string的实际长度</span></span><br><span class="line">    <span class="keyword">int</span> originalLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> numberOfBlank = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; string[i] != <span class="string">&#x27;\0&#x27;</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        originalLength++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (string[i] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            numberOfBlank++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// newLength为将空格替换为&#x27;%20&#x27;之后的长度</span></span><br><span class="line">    <span class="keyword">int</span> newLength = originalLength + numberOfBlank * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (newLength &gt; length)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> indexOfOriginal = originalLength;</span><br><span class="line">    <span class="keyword">int</span> indexOfNew = newLength;</span><br><span class="line">    <span class="keyword">while</span>(indexOfOriginal &gt;=<span class="number">0</span> &amp;&amp; indexOfNew &gt; indexOfOriginal)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (string[indexOfOriginal] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            string[indexOfNew --] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            string[indexOfNew --] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">            string[indexOfNew --] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            string[indexOfNew --] = string[indexOfOriginal];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        -- indexOfOriginal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>测试用例： </strong></p>
<ul>
<li>输入的字符串中包含空格（位于字符串的最前面，最后面，中间，连续多个空格）。</li>
<li>输入的字符串中没有空格。</li>
<li>特殊输入测试（字符串是个NULL指针、空字符串、只有一个空格字符、只有连续多个空格）。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>本题考点： </strong></p>
<ul>
<li>考查对字符串的编程能力。</li>
<li>考查分析时间效率的能力。</li>
<li>考查对内存覆盖是否有高度的警惕。能够意识到潜在的问题，并主动和面试官沟通以寻找问题的解决方案。</li>
<li>考查思维能力。在从前到后替换的思路被面试官否定之后，能迅速想到从后往前替换的方法。</li>
</ul>
</blockquote>
<p><strong>相关题目: </strong>
有两个排序的数组<code>A1</code>和<code>A2</code>，内存在<code>A1</code>的末尾有足够多的空余空间容纳<code>A2</code>。
请实现一个函数，把<code>A2</code>中的所有数字插入到<code>A1</code>中并且所有的数字是排序的。</p>
<blockquote>
<p>很多人首先想到的办法是在A1中从头到尾复制数字，但这样就会出现多次复制一个数字的情况。
更好的办法是从尾到头比较A1和A2中的数字，并把较大的数字复制到A1的合适位置。</p>
</blockquote>
<p><strong>举一反三：</strong>
合并两个数组（包括字符串）时，如果从前往后复制每个数字（或字符）需要重复移动数字（或字符）多次，
那么我们可以==考虑从后往前复制==，这样就能减少移动的次数，从而提高效率。</p>
<h3 id="链表">2.3.3　链表</h3>
<p>由指针把若干个结点连接成链状结构。</p>
<p>我们说链表是一种==动态数据结构==，是因为在创建链表时，==无须知道链表的长度==。
当插入一个结点时为新结点分配内存，然后调整指针的指向来确保新结点被链接到链表当中。
由于没有闲置的内存，链表的==空间效率比数组高==。</p>
<p>如果单向链表的结点定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> m_nValue;</span><br><span class="line">    ListNode* m_pNext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>则在链表末尾添加一个节点的C++代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddToTail</span><span class="params">(ListNode** pHead, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode* pNew = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">    pNew-&gt;m_nValue = value;</span><br><span class="line">    pNew-&gt;m_nNext = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (*pHead == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *pHead = pNew;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ListNode *pNode = *pHead;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(pNode-&gt;m_pNext != <span class="literal">NULL</span>)</span><br><span class="line">            pNode = pNode-&gt;m_pNext;</span><br><span class="line">        </span><br><span class="line">        pNode-&gt;m_pNext = pNew;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想在链表中找到它的第<code>i</code>个结点，我们只能从头结点开始遍历链表，时间效率为<span
class="math inline">\(O(N)\)</span>。 而在数组中，可以根据下标在<span
class="math inline">\(O(1)\)</span>内找到第<code>i</code>个元素。</p>
<p>在链表中找到第一个含有某值的结点并删除该结点的代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RemoveNode</span><span class="params">(ListNode** pHead, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pHead == <span class="literal">NULL</span> || *pHead == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    ListNode* pToBeDeleted = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>((*pHead)-&gt;m_nValue==value)</span><br><span class="line">    &#123;</span><br><span class="line">        pToBeDeleted = *pHead;</span><br><span class="line">        *pHead = (*pHead)-&gt;m_pNext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* pNode = *pHead;</span><br><span class="line">        <span class="keyword">while</span>(pNode-&gt;m_pNext != <span class="literal">NULL</span></span><br><span class="line">           &amp;&amp; pNode-&gt;m_pNext-&gt;m_nValue != value)</span><br><span class="line">           pNode = pNode-&gt;m_pNext;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (pNode-&gt;m_pNext != <span class="literal">NULL</span> &amp;&amp; pNode-&gt;m_pNext-&gt;m_nValue == value)</span><br><span class="line">        &#123;</span><br><span class="line">            pToBeDeleted = pNode-&gt;m_pNext;</span><br><span class="line">            pNode-&gt;m_pNext = pNode-&gt;m_pNext-&gt;m_pNext;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pToBeDeleted != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="keyword">delete</span> pToBeDeleted;</span><br><span class="line">            pToBeDeleted = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了简单的单向链表面试题: 面试题5“从尾到头输出链表”、面试题13“在<span
class="math inline">\(O(1)\)</span>时间删除链表结点”、面试题15“链表中的倒数第k个结点”、面试题16“反转链表”、面试题17“合并两个排序的链表”、面试题37“两个链表的第一个公共结点”等；</p>
<p>链表的其他形式面试题: 面试题45“圆圈中最后剩下的数字”(环形链表);
面试题27“二叉搜索树与双向链表” (双向链表); 面试题26“复杂链表的复制”
(复杂链表:
链表中的结点中除了有指向下一个结点的指针，还有指向任意结点的指针。)</p>
<h4 id="面试题5从尾到头打印链表">面试题5：从尾到头打印链表</h4>
<p>输入一个链表的头结点，从尾到头反过来打印出每个结点的值。链表结点定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> m_nValue;</span><br><span class="line">    ListNode* m_pNext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>看到这道题后，很多人自然地想到把链表中链接结点的指针反转过来，就可以从头到尾输出了。
但该方法会改变原来链表的结构。
是否允许在打印链表的时候修改链表的结构？这个取决于面试官的需求，在面试的时候我们要询问清楚。</p>
</blockquote>
<p><strong>面试小提示</strong>：
==在面试中如果我们打算修改输入的数据，最好先问面试官是不是允许做修改==。
通常打印是一个只读操作，我们不希望打印时修改内容。</p>
<blockquote>
<p>假设面试官也要求这个题目不能改变链表的结构。</p>
<p>接下来我们想到解决这个问题肯定要遍历链表。
遍历的顺序是从头到尾的顺序，可输出的顺序却是从尾到头。
这就是典型的“后进先出”，可以用栈实现这种顺序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintListReversingly_Iteratively</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::stack&lt;ListNode*&gt; nodes;</span><br><span class="line">    </span><br><span class="line">    ListNode* pNode = pHead;</span><br><span class="line">    <span class="keyword">while</span>(pNode != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        nodes.<span class="built_in">push</span>(pNode);</span><br><span class="line">        pNode = pNode-&gt;m_pNext;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!nodes.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        pNode = nodes.<span class="built_in">top</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, pNode-&gt;m_nValue);</span><br><span class="line">        nodes.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>由于用栈来实现这个函数，而递归本质上就是一个栈结构，因此可以很自然地用递归实现。
每访问到一个结点的时候，先递归输出它后面的结点，再输出该结点自身:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintListReversingly_Recursively</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pHead != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead-&gt;m_pNext != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">PrintListReversingly_Recursively</span>(pHead-&gt;m_pNext);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, pHead-&gt;m_nValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归代码看起来很简洁，但当链表很长时，函数调用的层级很深，可能导致函数调用栈溢出。
显式用栈基于循环实现的代码的鲁棒性会好一些。</p>
</blockquote>
<blockquote>
<p><strong>测试用例：</strong></p>
<ul>
<li>功能测试（输入的链表有多个结点; 只有一个结点）。</li>
<li>特殊输入测试（输入的链表头结点指针为NULL）。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>本题考点： </strong></p>
<ul>
<li>考查对单项链表的理解和编程能力。</li>
<li>考查对循环、递归和栈3个相互关联的概念的理解。</li>
</ul>
</blockquote>
<h3 id="树">2.3.4　树</h3>
<p>除了根结点之外每个结点只有一个父结点，根结点没有父结点；
除了叶结点之外所有结点都有一个或多个子结点，叶结点没有子结点。
父结点和子结点之间用指针链接。</p>
<p>由于树的操作会==涉及大量的复杂指针操作==。</p>
<p><strong>二叉树</strong>是树的一种特殊结构，在二叉树中每个结点最多只能有两个子结点。
在二叉树中最重要的操作莫过于==遍历==。</p>
<center>
<p><img src="https://gyazo.com/c7f8066bc686a31c224106376b3c27dd.png" style="zoom:67%;" /></p>
<ul>
<li><strong>前序遍历</strong>：先访问根结点，再访问左子结点，最后访问右子结点。
图2.5中的二叉树的前序遍历的顺序是10、6、4、8、14、12、16。</li>
<li><strong>中序遍历</strong>：先访问左子结点，再访问根结点，最后访问右子结点。
图2.5中的二叉树的中序遍历的顺序是4、6、8、10、12、14、16。</li>
<li><strong>后序遍历</strong>：先访问左子结点，再访问右子结点，最后访问根结点。
图2.5中的二叉树的后序遍历的顺序是4、8、6、12、16、14、10。</li>
</ul>
<p>这3种遍历都有递归和循环两种不同的实现方法，==每一种遍历的递归实现都比循环实现要简捷很多==。</p>
<ul>
<li><strong>宽度优先遍历</strong>：先访问树的第一层结点，再访问树的第二层结点……一直到访问到最下面一层结点。
在同一层结点中，以从左到右的顺序依次访问。
可以对包括二叉树在内的所有树进行宽度优先遍历。
图2.5中的二叉树的宽度优先遍历的顺序是10、6、14、4、8、12、16。</li>
</ul>
<p>相关的面试题:
面试题39“二叉树的深度”、面试题18“树的子结构”、面试题25“二叉树中和为某一值的路径”、面试题6“重建二叉树”、面试题24“二叉树的后序遍历序列”、面试题23“从上到下遍历二叉树”。</p>
<p><strong>二叉搜索树</strong>: 二叉树的一种特例。
在二叉搜索树中，左子结点总是小于或等于根结点，而右子结点总是大于或等于根结点。
图2.5中的二叉树就是一棵二叉搜索树。</p>
<center>
<p><img src="https://gyazo.com/c7f8066bc686a31c224106376b3c27dd.png" style="zoom:67%;" /></p>
<p>我们可以平均在 <span class="math inline">\(O(\log{n})\)</span>
的时间内根据数值在二叉搜索树中找到一个结点。 相关面试题:
面试题50“树中两个结点的最低公共祖先”、面试题27“二叉搜索树与双向链表”。</p>
<p><strong>堆和红黑树</strong>: 二叉树的另外两个特例。</p>
<p>堆分为<strong>最大堆</strong>和<strong>最小堆</strong>。
在最大堆中根结点的值最大，在最小堆中根结点的值最小。
有很多需要快速找到最大值或者最小值的问题都可以用堆来解决。</p>
<p>红黑树是把树中的结点定义为红、黑两种颜色，
并通过规则确保==从根结点到叶结点的最长路径的长度不超过最短路径的两倍==。
在C++的STL中，<code>set</code>、<code>multiset</code>、<code>map</code>、<code>multimap</code>等数据结构都是==基于红黑树实现==的。</p>
<p>与堆和红黑树相关的面试题：面试题30“求最小的k个数字”。</p>
<h4 id="面试题6重建二叉树">面试题6：重建二叉树</h4>
<p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。
假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
例如输入前序遍历序列<code>&#123;1,2,4,7,3,5,6,8&#125;</code>和中序遍历序列<code>&#123;4,7,2,1,5,3,8,6&#125;</code>，
则重建出图2.6所示的二叉树并输出它的头结点。</p>
<center>
<img src="https://gyazo.com/817afe3c78f09df19906ccca04399231.png" style="zoom: 67%;" />
</center>
二叉树结点的定义如下：
<center>
<img src="https://gyazo.com/131413d2cd8d18c3e9ea54194da4766c.png" style="zoom: 50%;" />
</center>
<h3 id="栈和队列">2.3.5 栈和队列</h3>
<p>栈在计算机领域被广泛应用。
例如，操作系统会给每个线程创建一个栈，用以存储函数调用时各个函数的参数、返回地址、临时变量等。</p>
<p>栈的特点是后进先出 (FILO).</p>
<p>栈通常不考虑排序，也就是需要<span
class="math inline">\(O(n)\)</span>的时间来寻找最值。 如果想要在<span
class="math inline">\(O(1)\)</span>的时间内找到最值，需要特殊的设计
(见面试题21)。</p>
<p>队列是另一种重要的结构。其特点是先进先出 (FIFO).</p>
<p>栈和队列针锋相对又相互联系。</p>
<h4 id="面试题7用两个栈实现队列">面试题7：用两个栈实现队列</h4>
<h2 id="算法和数据操作">2.4 算法和数据操作</h2>
<p>排序和查找是面试时考察算法的重点。
我们应该熟记二分查找、归并排序、快速排序的代码。</p>
<p>很多算法都可以以循环和递归两种方式来实现。
通常，基于递归的实现会比较简洁，但性能一般不如循环的实现。</p>
<p>位运算也是一种特殊的算法，是把数字表示为二进制之后对0和1进行操作。
它并不复杂，一共只有与、或、异或、左移、右移5种位运算。</p>
<h3 id="查找和排序">2.4.1 查找和排序</h3>
<p>查找相较简单，包括顺序查找、二分查找、哈希表查找和二叉排序树查找。
在面试时，必须信手拈来写得出二分查找的代码。 相关面试题:
面试题38，面试题8.</p>
<p>面试小提示： 如果题目要求「在排序 (或者部分排序)
的数组中查找一个数字或者统计某个数字的出现次数」，则可以尝试使用二分查找。</p>
<p>哈希表和二叉排序树的查找的重点在于数据结构而不是算法。</p>
<p>哈希表的优点是能够在<span
class="math inline">\(O(1)\)</span>内查找某元素，但缺点在于需要额外的空间。
相关面试题: 面试题35.</p>
<p>二叉排序树查找算法的对应数据结构是二叉搜索树。 相关面试题:
面试题24，面试题27.</p>
<p>排序比查找复杂一些，常见的包括插入排序、冒泡排序、归并排序、快速排序等。
面试官常要求应聘者比较不同算法的优劣。
因此一定要对各种排序算法的特点烂熟于心，
能够从额外空间消耗、平均时间复杂度、最差时间复杂度等方面去比较。</p>
<p>很多面试官要求应聘者写出快速排序的代码。
其关键在于在数组中选择一个数字，然后把数组中的数字分为两个部分，
比选择的数字小的移到数组左边，比选择的数字大的移到数组右边。
这个函数的实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> []data, <span class="keyword">int</span> length, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="literal">NULL</span> || length &lt;= <span class="number">0</span> || start &lt; <span class="number">0</span> || end &gt;= length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> std::<span class="built_in">exception</span>(<span class="string">&quot;Invalid Parameters&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> index = <span class="built_in">RandomInRange</span>(start, end);</span><br><span class="line">    <span class="built_in">Swap</span>(&amp;data[index], &amp;data[end]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> small = start - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (index = start; index &lt; end; ++ index)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(data[index] &lt; data[end])</span><br><span class="line">        &#123;</span><br><span class="line">            ++ small;</span><br><span class="line">            <span class="keyword">if</span>(small != index)</span><br><span class="line">                <span class="built_in">Swap</span>(&amp;data[index], &amp;data[small]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ++small;</span><br><span class="line">    <span class="built_in">Swap</span>(&amp;data[index], &amp;data[small]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> small;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%89%91%E6%8C%87Offer/" rel="tag"># 剑指Offer</a>
              <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag"># 读书笔记</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/05/24/Reading/Books/%E5%89%91%E6%8C%87Offer%20%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E9%9D%A2%E8%AF%95%E9%9C%80%E8%A6%81%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%20(%E4%B8%8A)/" rel="prev" title="《剑指Offer》第二章 笔记(上)">
                  <i class="fa fa-chevron-left"></i> 《剑指Offer》第二章 笔记(上)
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/05/24/Tutorial/Adding%20an%20existing%20local%20project%20to%20GitHub%20with%20Git/" rel="next" title="Adding an existing local project to GitHub with Git">
                  Adding an existing local project to GitHub with Git <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CHEN XUEYI</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div><script color="100,100,100" opacity="0.7" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"all","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
